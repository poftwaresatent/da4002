<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-gb" lang="en-gb">
<head>
  <meta http-equiv="content-type" content="text/html">
  <title>itads 2012 / exercise 4</title>
  <link rel="stylesheet" href="style.css" type="text/css">
</head>

<body>

<h1>ITADS 2012 exercise 4<br/>lists, stacks, queues</h1>



<h2>exercise 4.1: singly-linked lists</h2>

<p>
The source file <a href="itads2012/ex4/person-list.c">person-list.c</a> is a partial implementation of a singly-linked list that stores information about persons.
A person is represented using the <tt>Person</tt> struct.
The list item type, which contains a pointer to a person and a pointer to the next item, are defined in the <tt>Item</tt> struct.
The list itself is defined in the <tt>List</tt> struct, which maintains a pointer to the first and last items (called <tt>head</tt> and <tt>tail</tt>) as well as a counter called <tt>size</tt> for keeping track of the number of items in the list.
</p>

<p>
Several functions are provided in the pertial implementation:
</p>

<dl>
  <dt>
    <tt>person_create</tt>
  </dt>
  <dd>
    takes a string and an integer, allocates memory for a new person, duplicates the string, and returns the freshly allocated <tt>Person</tt>.
    In case of error, it returns <tt>NULL</tt>
  </dd>
  <dt>
    <tt>person_destroy</tt>
  </dt>
  <dd>
    takes a pointer to a person, and frees the memory used by it.
    Notice that it has to free two separate memory regions: the one taken up by the name, and the one taken up by the <tt>Person</tt> struct itself.
  </dd>
  <dt>
    <tt>person_print</tt>
  </dt>
  <dd>
    takes a pointer to a person and prints it on a single line to the terminal.
  </dd>
  <dt>
    <tt>list_init</tt>
  </dt>
  <dd>
    takes a pointer to a list and initializes it.
    This is necessary before using the list to store items.
  </dd>
  <dt>
    <tt>list_destroy</tt>
  </dt>
  <dd>
    takes a pointer to a list, frees all the memory allocated by its items, and re-initializes it.
    Notice that it uses the <tt>person_destroy</tt> function to make sure all that memory gets properly freed, and calls <tt>free</tt> on the items after that.
  </dd>
  <dt>
    <tt>list_ins_next</tt>
  </dt>
  <dd>
    inserts a new item into a list, such that the new item will come after the specified position.
    Takes a list pointer, an item pointer (which is the position after which the insertion should happen), and a pointer to a person.
    As a special case, when you pass <tt>pos=NULL</tt> to this function, then the new item will be inserted at the head of the list.
    The <tt>list_ins_next</tt> function allocates memory for the new item, but does not duplicate the given person.
    It returns zero on success.
  </dd>
  <dt>
    <tt>list_rem_next</tt>
  </dt>
  <dd>
    is just a placeholder to be filled in by you (see the first task of this exercise).
    It is responsible for removing the item that comes after the given position.
    Notice that it has to properly free all the memory used by the removed item.
    As a special case, when you pass <tt>pos=NULL</tt>, the head of the list should be removed.
    This function also should return zero on success.
  </dd>
  <dt>
    <tt>list_dump</tt>
  </dt>
  <dd>
    is a utility function that iterates over all items of the list and calls <tt>person_print</tt> on the data stored in each of them.
  </dd>
  <dt>
    <tt>populate</tt>
  </dt>
  <dd>
    is a utility function which inserts some example persons into a list.
  </dd>
  <dt>
    <tt>main</tt>
  </dt>
  <dd>
    populates a list with some example people, prints the list, then removes everyone who is younger than 18, and prints the resulting shorter list.
    This is meant as a test for the first task, which is to implement <tt>list_rem_next</tt>
  </dd>
</dl>

<p>
Based on this program and the description of the functions, perform the following tasks:
</p>

<ol>
  <li>
    Implement <tt>list_rem_next</tt>.
    Check your implementation by compiling and running <tt>person-list</tt>.
    At the end, your output should look like this:
    <pre class="command">
population:
  Alice Doe       is 28 years old
  Bob Doe         is 31 years old
  Charlie Doe     is  1 year  old
  Doris Doe       is  5 years old
  Arnold Fox      is 42 years old
  Barbara Fox     is 43 years old
  Cindy Fox       is 19 years old
  Daniel Fox      is 17 years old
  Eric Fox        is 15 years old

removing Charlie Doe
removing Doris Doe
removing Daniel Fox
removing Eric Fox

persons allowed to vote:
  Alice Doe       is 28 years old
  Bob Doe         is 31 years old
  Arnold Fox      is 42 years old
  Barbara Fox     is 43 years old
  Cindy Fox       is 19 years old</pre>
  </li>
  <li>
    Modify <tt>list_rem_next</tt> such that it can return the person that was stored in the removed element via a third argument.
    This third argument is a pointer to a person-pointer, so the new function signature should look exactly like this:
    <pre class="sourcecode">
int list_rem_next (List * list, Item * pos, Person ** data)</pre>
    As a special case, when <tt>data=NULL</tt>, the memory where the person data is stored in the item should be freed, as before.
	But when <tt>data</tt> points to a person-pointer, the person data stored in the item should be placed there.
	Notice that this interface change will require you to adapt the code in <tt>main</tt> as well, but your change should not modify the behavior of the program.
  </li>
</ol>



<h2>exercise 4.2: a list-based stack</h2>

<p>
Implement a stack by using the list implementation you just completed, with the extended <tt>list_rem_next</tt> function.
The stack should have the following interface:
</p>

<dl>
  <dt>
    <tt>stack_push</tt>
  </dt>
  <dd>
    takes a stack and a person as argument, places the person on the top of the stack, and returns zero on success.
  </dd>
  <dt>
    <tt>stack_pop</tt>
  </dt>
  <dd>
    takes a stack as argument, removes the topmost element, and returns the person stored there.
    In case <tt>stack_pop</tt> is called on an empty stack, it should return <tt>NULL</tt>.
    Take care to free the memory used by the item, <b>but not</b> the memory used by the person.
  </dd>
</dl>

<p>
<em><u>Hint</u>: this task is really very quick.
You "just" have to call the appropriate list operations in the correct order and pass them the approriate arguments.
The body of <tt>stack_push</tt> can be done in a single line of code, and <tt>stack_pop</tt> can be done in 4 lines.</em>
</p>

<p>
Test your implementation by replacing the <tt>main</tt> function with the following:
</p>

<pre class="sourcecode">
int main (int argc, char ** argv)
{
  List stack;
  Person *p1, *p2;
  
  list_init (&stack);
  if (NULL == (p1 = person_create ("Richard Feynman", 2012 - 1918)))
    goto fail1;
  if (NULL == (p2 = person_create ("Richard The Third", 2012 - 1452)))
    goto fail2;  
  if (0 != stack_push (&stack, p1))
    goto fail3;
  if (0 != stack_push (&stack, p2))
    goto fail3;
  
  while (NULL != (p1 = stack_pop (&stack)))
    person_print (p1);
  
  list_destroy (&stack);
  return 0;
  
 fail3:
  person_destroy (p2);
 fail2:
  person_destroy (p1);
 fail1:
  list_destroy (&stack);
  return 1;
}</pre>

<p>
When running this program, you should see the following output:
</p>

<pre class="command">
  Richard The Third is 560 years old
  Richard Feynman is 94 years old</pre>

<p>
Notice that the two are printed in the opposite order from their assigment.
</p>


<h2>exercise 4.3: <tt>void*</tt>, pointer casts, and function pointers</h2>


<ol>
  <li>
    Download <a href="itads2012/ex4/pointer-casts-explicit.c">pointer-casts-explicit.c</a> and study the heavily documented code.
    Then compile and run it, and use the program output to make sure you understand the explanations about generic pointers that are given in the code.
  </li>
  <li>
    Do the same with <a href="itads2012/ex4/pointer-casts-implicit.c">pointer-casts-implicit.c</a>.
  </li>
  <li>
    Download <a href="itads2012/ex4/function-pointers.c">function-pointers.c</a> and study the heavily documented code.
    Then compile and run it, and use the program output to make sure you understand the explanations about generic pointers that are given in the code.
  </li>
  <li>
    Add a function "<tt>product</tt>" to the <tt>function-pointers.c</tt> program.
    The <tt>product</tt> function should take <b>two</b> pointers to double, compute the product of the values they point to, and store the result in the first of the two.
    Then, at the end of <tt>main</tt>, call the "<tt>apply_fct2</tt>" in order to apply the <tt>product</tt> function to the array.
    Print the resulting array, the result should look like this:
    <pre class="command">
after the product function:
  144.000000
  36.000000
  4.000000
  0.000000
  0.000000
  4.000000
  36.000000
  144.000000
  400.000000
  25.000000</pre>
  </li>
</ol>



<h2>exercise 4.4: a generic doubly-linked list</h2>



2. make it generic
   - warm-up exercise about void* and pointer casts
     ./ . first just builtin types, e.g. with arithmetic
     ./ . then a short example (with structs and) passing pointers into functions
   - warm-up exercise about function pointers
     ./ . apply a function to each value in an array
     xx . store a function pointer in a struct along with some value
   - make a semi-generic list_visit() which calls a function for each item->data
     . do this on the list of persons to print using various formats
     . one without age
     . one with the age before the name
   - have them adapt the linked list to it
     guided by a main() which maintains two lists, one of int and one of char*
     needs to separate list_dump() functions (for now)
   - set a custom item destructor (i.e. person_destroy) in the list
     constructor

</body>
</html>
