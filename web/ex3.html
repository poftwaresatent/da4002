<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-gb" lang="en-gb">
<head>
  <meta http-equiv="content-type" content="text/html">
  <title>itads 2012 / exercise 3</title>
  <link rel="stylesheet" href="style.css" type="text/css">
</head>

<body>

<h1>ITADS 2012 exercise 3<br/>structs and vectors</h1>



<h2>exercise 3.x: vectors</h2>

<p>
The source file <a href="itads2012/ex3/vector.c"><tt>vector.c</tt></a> is a partial implementation of a dynamic array.
It closely follows the example presented in lecture 2 (<a href="itads2012/slides/02-vectors-and-lists-print.pdf">handout</a>).
There are several functions that still need to be filled in, but the source already provides an application that is ready to run.
</p>

<ol>
  <li>
    Compile and run the <tt>vector</tt> program.
    Notice that it performs a series of checks, called <em>unit tests</em>, which allow to quickly determine whether an implementation is complete.
    Study the <tt>vector_append</tt> function (starting on line 89 of <tt>vector.c</tt>) and make sure you understand what it does by matching it with the relevant part of the messages printed by the <tt>vector</tt> program.
  </li>
  <li>
    Fill in the function <tt>vector_prepend</tt> (starting on line 127 of <tt>vector.c</tt>).
    It is probably easiest to start by studying what <tt>vector_append</tt> does, and following the same general implementation pattern.
    Verify that your implementation is correct by running the <tt>vector</tt> program and analysing the output produced by the <tt>test_prepend</tt> function.
  </li>
  <li>
    Fill in the function <tt>vector_insert</tt> (starting on line 153 of <tt>vector.c</tt>).
    You can get inspiration from the <tt>vector_prepend</tt> function that you just implemented.
    Again, verify that your implementation is correct by analysing the unit test output produced by running the <tt>vector</tt> program.
  </li>
  <li>
    Fill in the <tt>vector_remove</tt> function (starting on line 183 of <tt>vector.c</tt>).
    By now you should have the hang of this kind of test-driven implementation approach, using repeated runs of the unit tests to find out when you're done.
  </li>
  <li>
    <em>Optional (advanced)</em><br/>
    The <tt>vector_grow</tt> utility function can be improved by using <tt>realloc</tt> instead of <tt>malloc</tt>.
    Read the <tt>realloc(3)</tt> manual page (either by typing "<tt>man realloc</tt>" into the terminal or looking at the <a href="http://www.linuxmanpages.com/man3/realloc.3.php">online version</a>) to find out how it works.
    Then, modify the <tt>vector_grow</tt> code to take advantage of it (you won't need <tt>memcpy</tt> anymore).
  </li>
</ol>



<h2>exercise 3.x: a vector-based stack</h2>

<p>
The source file <a href="itads2012/ex3/stack.c"><tt>stack.c</tt></a> is a partial implementation of a program that prints the lines of a given file in reverse order.
The idea is simple: push all the lines onto a stack, then pop and print until the stack is empty.
Three of the required stack operations have not been implemented yet, but the source code contains instructions and hints.
</p>

<ol>
  <li>
    Implement the function <tt>stack_grow</tt> (line 73).
  </li>
  <li>
    Implement the function <tt>stack_push</tt> (line 97).
  </li>
  <li>
    Implement the function <tt>stack_pop</tt> (line 120).
  </li>
</ol>

<p>
Test your implementation by passing a text file, for example the source code itself, to the program, such as:
</p>

<pre class="command">
./stack stack.c
</pre>

</body>
</html>
