\documentclass[a4paper]{article}

\usepackage[margin=3.5cm]{geometry}
\usepackage{verbatim,amsmath}

\begin{document}

\title{
  {\small
    Halmstad University course DA4002\\
    Introduction to Algorithms, Data Structures, and Problem Solving\\
  }
  Group Activities for Lecture 4
}
\maketitle



\section{Stack and Queue Implementation}

This is a pen-and-paper design and implementation activity emphasizing skills didactic and teamwork skills.

Students are alternatingly assigned to groups A and B.
Everyone receives a printout of source code for vectors and singly linked lists.
Each student then individually and independently creates an implementation of either a stack (group A) or a queue (group B) according to a specified interface.
This should take only a couple of minutes.

Then, each student from group A explains their implementation to a student from group B.
Explain what you have done and why.
Draw sketches or diagrams to clearly illustrate the most important points.
After a few minutes, reverse the roles:
group B students now explain their implementation to group A students.

Now that the stack and queue implementations are clarified, the pairs of students work together to design and sketch a test program that can be used to verify that the data structure implementations are correct.
It is important to focus not only on what the various operations should do, but also on things that could go wrong in case of incorrect implementations.
This should also take only a couple of minutes.

\emph{The results of the exercise are not handed in.
  To check whether the implementations are correct, the students can later write the test program that they designed.}



\section{Working with Big-Oh Expressions}

Together with another student (for example the same as for the previous activity), discuss and write down the ``Big-Oh'' complexity expression $O(N)$ for the following execution times $T(N)$.

\begin{align}
  T(N) &= 0.15 N^2 + 23.5 \log N
  \\
  T(N) &= N (5N + (22 + 0.01N^2) \log N) + 2.1 \cdot 2^N
  \\
  T(N) &= \sum_{i=1}^Ni
  \\
  T(N) &=
  \begin{cases}
    0          & \text{for} N < 1 \\
    N + T(N-1) & \text{otherwise}
  \end{cases}
  \\
  T(N) &=
  \begin{cases}
    1        & \text{for} N \leq 1 \\
    2 T(N-1) & \text{otherwise}
  \end{cases}
\end{align}



\section{Analyzing Insertion Sort}

Together with another student, manually trace the execution of an example program that applies insertion sort to a small array.
Write down what the contents of the array look like at each of the outer iterations of the algorithm.
This is expected to take only a few minutes.

Then, also together with the other student, extract an execution time expression $T(N)$ from the insertion sort code.
What is the natural choice for $N$?
What happens in the worst case in each of the loops of the algorithm?
After a few minutes of discussion, move on to the next activity.



\section{Analysis of Merge Sort}

Similarly to the previous activity, analyze what happens when merge sort is applied to a given small array.
Note that this example code contains \emph{printf} statements: as you trace the execution of this program, write down what it would print.
Also make a sketch of how the array contents evolve through the different stages.

After some minutes, after you have a grasp on how the recursion makes merge sort work, extract an execution time expression $T(N)$ for it.

This algorithm is expected to be more difficult to analyze than the previous one.
Write down and discuss what exactly made it more difficult for you personally.



\end{document}
