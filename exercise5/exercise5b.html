<h1>ITADS Exercise 5b: Dynamic Programming</h1>



<h2>exercise 5.4: grid-based motion planning</h2>

<p>
  Many applications require automated path planning:
  for example to lay out conductors in electronic circuit boards, find ways of routing network cables in a building, or planning a road trip.
  Frequently, the objective is not to find just any path, but "the best" one.
  For example, the path with the shortest length, or the one which minimizes the expected travel time.
</p>

<p>
  For problems that can be described as binary two-dimensional grids, where grid cells are either free or occupied, there is a relatively simple algorithm to produce shortest paths.
  It is called NF1, and it employs the so-called <a href="http://en.wikipedia.org/wiki/Manhattan_distance">Manhattan distance</a> to compare path lengths.
  This is a coarse approximation, but sufficient for many applications.
  The image below (figure 1) illustrates of the type of paths produced by NF1.
</p>

<table border="1">
  <tr><td><img src="blah"/></td></tr>
  <tr><td>
      <em>Figure 1:</em>
      The NF1 is a relatively simple algorithm that constructs a discrete <a href="http://en.wikipedia.org/wiki/Scalar_potential">potential function</a> with a unique minimum at the goal location.
      It works by assigning a natural number to each cell that is reachable from the goal.
      Once these numbers have been assigned, you can reach the goal by step by step, each time picking the neighboring cell with the smallest such number.
  </td></tr>
</table>

<p>
  The NF1 algorithm starts by assigning 0 to the goal, then iteratively assiging increasing numbers (1, 2, 3, ...) to cells that lie farther and farther away.
  The underlying idea is rather simple:
  divide the environment into equally sized grid cells, mark all obstacle cells with a special value, then construct a monotonically increasing potential starting at the cells that are in the goal region.
  It can be implemented as a cell-labeling method which never goes into obstacles and never overwrites labels which have been written before.
  Thus, each cell gets visited at most once, and only immediately after one of its neighbors has been visited.
  This is illustrated in figure 2.
</p>

<table border="1">
  <tr><td><img src="blah"/></td></tr>
  <tr><td>
      <em>Figure 2:</em>
      NF1 example.
      The goal is initialized to 0 and obstacles are denoted with "X".
      On the left is the initialized grid.
      The grid after fully completing the algorithm is shown on the right.
      By filling the grid with consecutive values of connected neighbors, a discrete navigation function is constructed.
      Being a true potential, you can find the goal from any cell by simply always stepping onto the neighboring cell with the smallest value.
  </td></tr>
</table>

<p>
  The NF1 is a simple example of dynamic programming.
  It has all the required attributes:
</p>

<dl>
  <dt>
    Overlapping Subproblems
  </dt>
  <dd>
    Finding the optimal path to a given cell requires finding the optimal path to its neighbors.
  </dd>
  <dt>
    Subproblems are only slightly smaller.
  </dt>
  <dd>
    Finding the optimal path to a neighbor is only one step shorter than finidng the optimal path to the target cell.
  </dd>
  <dt>
    Optimal Structure
  </dt>
  <dd>
    When we divide an optimal path in two parts anywhere along its length, each part has to be the optimal path between its respective end points.
  </dd>
</dl>

<p>
  In this exercise, you will implement the NF1 function for finding paths through rooms of a house.
  The floorplan is represented as a grid, where walls are marked as obstacles.
  Open spaces and doors are marked as freely traversable.
  Apart from the method which propagates the potential function, the application in <a href="itads/exercise5/Mansion.java">Mansion.java</a> is already finished and ready to run.
  It also needs the <a href="itads/exercise5/Pair.java">Pair.java</a> source file.
  In particular, the existing Mansion.java contains code for parsing command line arguments and backtracking the path for display on the console.
  The portion of code which you have to implement is clearly marked inside the <tt>propagate</tt> method.
</p>

<p>
  Running the <tt>Mansion</tt> program prints the floor plan and gives instructions on how to specify the start and goal on the command line.
  For example:
</p>

<p class="command">
java Mansion<br/>
  abcdefghijklmn<br/>
 ################<br/>
0#     #        #0<br/>
1#     #        #1<br/>
2#              #2<br/>
3#     #        #3<br/>
4#######        #4<br/>
5#     #        #5<br/>
6#     #        #6<br/>
7#     ## #### ##7<br/>
8#     #        #8<br/>
9#              #9<br/>
 ################<br/>
  abcdefghijklmn<br/>
<br/>
Please specify start and goal coordinates, for instance `a0 n9'
</p>

<p>
  The walls of the mansion are indicated by the "<tt><b>#</b></tt>" symbols.
  The coordinate system along X goes from <tt>a</tt> to <tt>n</tt>, and along Y it uses numbers from <tt>0</tt> to <tt>9</tt>.
  So, in order to specify the lower-left cell as a start location, you would pass "<tt><b>a9</b></tt>" on the command line.
</p>

<p>
  Once your implementation is done, you can see the plans it creates for different start and goal locations.
  For example:
</p>

<p class="command">
java Mansion m0 e5<br/>
  abcdefghijklmn<br/>
 ################<br/>
0#     #      + #0<br/>
1#     #     o  #1<br/>
2#          o   #2<br/>
3#     #   o    #3<br/>
4#######  o     #4<br/>
5#    x# o      #5<br/>
6#    o# o      #6<br/>
7#    o##o#### ##7<br/>
8#    o#o       #8<br/>
9#     o        #9<br/>
 ################<br/>
  abcdefghijklmn
</p>

<p>
  As you can see, the start is marked with a "<tt><b>+</b></tt>" sign, the goal with a "<tt><b>x</b></tt>", and all the cells which lie on the optimal path are marked as "<tt><b>o</b></tt>".
  Or, setting a different start and goal:
</p>

<p class="command">
java Mansion a3 a7<br/>
  abcdefghijklmn<br/>
 ################<br/>
0#     #        #0<br/>
1#     #        #1<br/>
2# ooooo        #2<br/>
3#+    #o       #3<br/>
4####### o      #4<br/>
5#     # o      #5<br/>
6#     # o      #6<br/>
7#xooo ##o#### ##7<br/>
8#    o#o       #8<br/>
9#     o        #9<br/>
 ################<br/>
  abcdefghijklmn
</p>
