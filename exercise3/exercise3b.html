<h1>ITADS Exercise 3a: Sorting Algorithms</h1>

<p>
  As before, it is recommended that you create a new directory for
  this exercise, and also that you use
  a <a href="itads/exercise3/Makefile">Makefile</a> to manage the
  building of executables. (Unless you are using Eclipse, which does
  not need <tt>make</tt> but uses its own internal tool instead.)
</p>



<h2>exercise 3.5: bubble sort</h2>

<p>
  Read the Wikipedia article
  on <a href="http://en.wikipedia.org/wiki/Bubble_sort">Bubble
  Sort</a>, one of the simplest sorting algorithms. Focus on section 2
  (implementation) but also consider parts of section 1 to understand
  the general idea behind the algorithm.
</p>

<p>
  Design and implement a <tt>BubbleSort</tt> class which sorts arrays
  of strings into alphabetical order. Write a <tt>main</tt> function
  which tests your implementation with the help of
  the <tt>createRandomStrings</tt> function
  from <a href="itads/exercise3/Factory.java">Factory.java</a>.
</p>



<h2>exercise 3.6: comparing insertion, merge, and bubble sort</h2>

<p>
  Download <a href="itads/exercise3/InsertionSort.java">InsertionSort.java</a> and
  <a href="itads/exercise3/MergeSort.java">MergeSort.java</a> files,
  which implement the sorting algorithms presented during lecture 3. Also download 
  <a href="itads/exercise3/SortingBenchmark.java">SortingBenchmark.java</a>
  which runs insertion and merge sort for various array lengths and
  measures how long each algorithm takes.
</p>

<p>
  Add your <tt>BubbleSort</tt> to the sorting benchmark. Pay attention
  to the fact that you have to create a new duplicate of the unsorted
  array of random numbers before running bubble sort.
</p>



<h2>exercise 3.7 <em>(optional)</em>: input data dependence</h2>

<p>
  The time required to sort a given array of strings can depend on
  whether the data is already partially sorted. In order to illustrate
  this fact, we will look at two extreme cases: fully sorted input
  data, and data which is in reverse order.
</p>

<ol>
  <li>
    Add a second set of measurements to the <tt>main</tt> function
    of <tt>SortingBenchmark</tt> in order to find out how long each
    algorithm takes to process data that is already sorted.
  </li>
  <li>
    Look at the different running times across algorithms, and notice
    the difference between the measurements on random versus
    already-sorted data. Try to explain these differences by analyzing
    how each sorting algorithm works.
  </li>
  <li>
    Add a third set of measurements to <tt>SortingBenchmark</tt>, this
    time on data that is sorted in reverse. Which algorithms suffer
    the most from this, and why?
  </li>
</ol>
