\documentclass[a4paper]{article}

\usepackage[pdftex]{graphicx}
\usepackage[margin=3cm]{geometry}
\usepackage{verbatim,moreverb,amssymb,amsmath}


\newcounter{question}
\newcommand{\question}[1]{\refstepcounter{question}\section*{Question~\thequestion~~~\small\emph{(#1)}}}
\renewcommand*\thequestion{\arabic{question}}


\begin{document}

\pagestyle{empty}
\thispagestyle{empty}



\noindent
\begin{minipage}{\columnwidth}
  \centering
  \Large
  DA4002 (HT11) Halmstad University\\
  Introduction to Algorithms, Data Structures, and Problem Solving\\[3\baselineskip]
  \Huge
  Written Exam\\
  \Large
  Tuesday, August 21, 2012\\[2\baselineskip]
  Examiner: Roland Philippsen
\end{minipage}

\vfill

\noindent
\begin{center}
\fbox{
  \begin{minipage}{0.8\columnwidth}
    \textbf{Student Name:}\\[3\baselineskip]
  \end{minipage}
}
\end{center}

\vfill



\section*{Rules}

Aside from the obvious rules of conduct exams (e.g.\ no chatting):

\begin{itemize}
\item
  \textbf{No computing devices} (laptops, phones, calculators, \emph{etc}).
\item
  \textbf{No books or printouts}.
\item
  \textbf{Allowed self-written notes}: two sheets of A4 paper (front and back).
\end{itemize}



\section*{General Guidelines}

\begin{itemize}
\item
  \textbf{Read carefully} and pace yourself.
  You can solve the problems in any order you want, but later problems may be easier to solve after you have answered the preceding questions.
\item
  \textbf{Write clearly} and draw clear diagrams.
  If you need to correct a mistake, then cleanly cross out the wrong answer and clearly indicate where the correction can be found.
\item
  \textbf{Indicate the question number} for each of your answers.
  If a question has sub-questions, indicate the sub-question number after the main question number, separated by a dot.
  For example, question 3 has 4 sub-questions, and their answers should be numbered 3.1, 3.2, 3.3, and 3.4.
\end{itemize}



\pagebreak
\pagestyle{plain}
\thispagestyle{plain}
\setcounter{page}{1}



\question{4 points}

identifying algorithms by analysing pseudocode
\begin{itemize}
\item linear search
\item sort (e.g.\ bubble sort, keep it very simple)
\item tree traversal (e.g.\ in-order, nicely recursive)
\item bfs (needs queue, is a bit more complex)
\end{itemize}



\question{4 points}

match ds diagrams with java code (and maybe usage scenarios?)
\begin{itemize}
\item circular linked list (task scheduling?)
\item child/sibling tree (language parsing?)
\item adjacency matrix (air travel planning?)
\end{itemize}



\question{2 points ?}

\emph{from Vero:}\\
I like the question related to the naive implementation of search trees using binary trees without any extra information: Say that you have a balanced tree (and then operations are order log N), then you save the contents into a file and to do so you traverse the tree in in-order (the elements get sorted). Then when you build the tree again by reading the elements from the file you will get a completely non balanced tree (the operations are order N!). So one can present the situation and then ask them how they would traverse the tree for stoing the elements.




\question{3 points}

manually run sequence alignment with two different cost tables, make them enumerate all alignments that have the same cost (make sure one of the examples has more than one minimum)



\question{6 points}

big-oh analysis of several iterative and recursive functions, or variations thereof:
\begin{itemize}
\item let them match program snippets with plots of (fake) runtime measurements
\item match relative runtime-changes with complexity classes
\item how big of a problem can be solved in X minutes for each of the algos, given that a problem of size N takes Y minutes?
\end{itemize}



\question{5 points?}

\emph{from Vero:}\\
I also like, as one of the initial questions, to warm up, to make an algorithm better by first sorting the elements:

An array contains \emph{N} numbers, and you want to determine
whether two numbers sum to a given number \emph{K}. For instance, if
the input array contains numbers 8, 4, 1, 6 and \emph{K} is 10, then
the answer is yes (4 and 6).
\begin{enumerate}
\item \textbf{(2 pts.)} Program a method
\begin{verbatim}
boolean sum2ToK (int [] a, int k)
\end{verbatim}
to do what you want.
\item \textbf{(2 pts.)} Give an execution time analysis of your method.
\item \textbf{(2 pts.)} Recall that there are algorithms for sorting arrays that are
  ${\cal O}(N \text{log}(N))$. Use this fact to write a new version of
  your program that is ${\cal O}(N \text{log}(N))$, proceed by first
  sorting the array \texttt{a} and then doing some linear extra work.
  \newline
  \underline{\textbf{Notice:}} You do NOT need to implement sort, you
  can assume that it is already programmed.
\end{enumerate}



\end{document}
