\documentclass[a4paper]{article}

\usepackage[pdftex]{graphicx}
\usepackage[margin=3cm]{geometry}
\usepackage{verbatim,moreverb,amssymb,amsmath}


\newcounter{question}
\newcommand{\question}[1]{\refstepcounter{question}\section*{Question~\thequestion~~~\small\emph{(#1)}}}
\renewcommand*\thequestion{\arabic{question}}


\begin{document}

\pagestyle{empty}
\thispagestyle{empty}



\noindent
\begin{minipage}{\columnwidth}
  \centering
  \Large
  DA4002 (HT11) Halmstad University\\
  Introduction to Algorithms, Data Structures, and Problem Solving\\[3\baselineskip]
  \Huge
  Written Exam\\
  \Large
  Tuesday, August 21, 2012\\[2\baselineskip]
  Examiner: Roland Philippsen
\end{minipage}

\vfill

\noindent
\begin{center}
\fbox{
  \begin{minipage}{0.8\columnwidth}
    \textbf{Student Name:}\\[3\baselineskip]
  \end{minipage}
}
\end{center}

\vfill



\section*{Rules}

Aside from the obvious rules of conduct exams (e.g.\ no chatting):

\begin{itemize}
\item
  \textbf{No computing devices} (laptops, phones, calculators, \emph{etc}).
\item
  \textbf{No books or printouts}.
\item
  \textbf{Allowed self-written notes}: two sheets of A4 paper (front and back).
\end{itemize}



\section*{General Guidelines}

\begin{itemize}
\item
  \textbf{Read carefully} and pace yourself.
  You can solve the problems in any order you want, but later problems may be easier to solve after you have answered the preceding questions.
\item
  \textbf{Write clearly} and draw clear diagrams.
  If you need to correct a mistake, then cleanly cross out the wrong answer and clearly indicate where the correction can be found.
\item
  \textbf{Indicate the question number} for each of your answers.
  If a question has sub-questions, indicate the sub-question number after the main question number, separated by a dot.
  For example, question 3 has 4 sub-questions, and their answers should be numbered 3.1, 3.2, 3.3, and 3.4.
\end{itemize}



\pagebreak
\pagestyle{plain}
\thispagestyle{plain}
\setcounter{page}{1}



\question{4 points}

Consider the following four pseudo-code fragments A, B, C, and D:\\[\baselineskip]

\small
\noindent
\begin{minipage}[t]{0.44\columnwidth}
  
  \begin{tabbing}
    \quad\=\quad\=\quad\=\quad\=\quad\=\kill
    function \textbf{fragmentA} (\emph{arr}, \emph{len}):\\
    \>// \emph{arr} is an array of numbers\\
    \>// \emph{len} is the length of the array\\
    \>for \emph{i} in 0\ldots\emph{len}-1:\\
    \>\>for \emph{j} in 1\ldots\emph{len}-1:\\
    \>\>\>if \emph{arr}[\emph{j}] $<$ \emph{arr}[\emph{j-1}] then\\
    \>\>\>\>swap \emph{arr}[\emph{j}] with \emph{arr}[\emph{j-1}]\\
    \>\>\>end if\\
    \>\>end for\\
    \>end for\\
    end function
  \end{tabbing}
  
  \begin{tabbing}
    \quad\=\quad\=\quad\=\quad\=\quad\=\kill
    function \textbf{fragmentC} (\emph{start})\\
    \>// - \emph{start} is a node\\
    \>// variables:\\
    \>// - \emph{open} is a queue of nodes\\
    \>// - \emph{closed} is a set of nodes\\
    \>// - \emph{it} and \emph{nb} are nodes\\
    \>\emph{open}.enqueue(\emph{start})\\
    \>while \emph{open} is not empty:\\
    \>\>\emph{it} = \emph{open}.dequeue()\\
    \>\>if \emph{closed} does not contain \emph{it} then\\
    \>\>\>\emph{closed}.add(\emph{it})\\
    \>\>\>for \emph{nb} in \emph{it}.neighbors:\\
    \>\>\>\>if \emph{closed} does not contain \emph{nb} then\\
    \>\>\>\>\>\emph{nb}.predecessor = \emph{it}\\
    \>\>\>\>\>\emph{open}.enqueue(\emph{nb})\\
    \>\>\>\>end if\\
    \>\>\>end for\\
    \>\>end if\\
    \>end while\\
    end function
  \end{tabbing}
  
\end{minipage}%
\hfill%
\begin{minipage}[t]{0.44\columnwidth}
  
  \begin{tabbing}
    \quad\=\quad\=\quad\=\quad\=\quad\=\kill
    function \textbf{fragmentB} (\emph{arr}, \emph{len}, \emph{num}):\\
    \>// - \emph{arr} is an array of numbers\\
    \>// - \emph{len} is the length of the array\\
    \>// - \emph{num} is a number\\
    \>for \emph{i} in 0\ldots\emph{len}-1:\\
    \>\>if \emph{arr}[\emph{i}] $=$ \emph{num} then\\
    \>\>\>return \emph{i}\\
    \>\>end if\\
    \>end for\\
    \>return -1\\
    end function
  \end{tabbing}
  
  \begin{tabbing}
    \quad\=\quad\=\quad\=\quad\=\quad\=\kill
    function \textbf{fragmentD} (\emph{start})\\
    \>// - \emph{start} is a node\\
    \>// NOTE:\\
    \>// \quad someFunction() can be assumed to be given,\\
    \>// \quad it does not matter what that function does.\\
    \>someFunction(\emph{start})\\
    \>if \emph{start}.left is not null then\\
    \>\>fragmentD(\emph{start}.left)\\
    \>end if\\
    \>if \emph{start}.right is not null then\\
    \>\>fragmentD(\emph{start}.right)\\
    \>end if\\
    end function
  \end{tabbing}
\end{minipage}
\normalsize
\vspace{\baselineskip}

For each of those code fragments, choose which algorithm name from the table below best corresponds to what the fragment does, and mark its letter \emph{(A, B, C, or D)} in the space on the right.
Mark algorithms which are not shown in any pseudo-code with a big \textbf{X}.

\begin{center}
  \begin{tabular}{|l|p{0.3\columnwidth}|}
    \hline
    \emph{algorithm} & \emph{A, B, C, D, or X} \\
    \hline
    linear search & \\
    \hline
    binary search & \\
    \hline
    sort & \\
    \hline
    pre-order tree traversal & \\
    \hline
    level-order tree traversal & \\
    \hline
    breadth-first search & \\
    \hline
  \end{tabular}
\end{center}

\clearpage




\question{4 points}

match ds diagrams with java code (and maybe usage scenarios?)
\begin{itemize}
\item circular linked list (task scheduling?)
\item child/sibling tree (language parsing?)
\item adjacency matrix (air travel planning?)
\end{itemize}



\question{2 points ?}

\emph{from Vero:}\\
I like the question related to the naive implementation of search trees using binary trees without any extra information: Say that you have a balanced tree (and then operations are order log N), then you save the contents into a file and to do so you traverse the tree in in-order (the elements get sorted). Then when you build the tree again by reading the elements from the file you will get a completely non balanced tree (the operations are order N!). So one can present the situation and then ask them how they would traverse the tree for stoing the elements.




\question{3 points}

manually run sequence alignment with two different cost tables, make them enumerate all alignments that have the same cost (make sure one of the examples has more than one minimum)



\question{6 points}

big-oh analysis of several iterative and recursive functions, or variations thereof:
\begin{itemize}
\item let them match program snippets with plots of (fake) runtime measurements
\item match relative runtime-changes with complexity classes
\item how big of a problem can be solved in X minutes for each of the algos, given that a problem of size N takes Y minutes?
\end{itemize}



\question{5 points?}

\emph{from Vero:}\\
I also like, as one of the initial questions, to warm up, to make an algorithm better by first sorting the elements:

An array contains \emph{N} numbers, and you want to determine
whether two numbers sum to a given number \emph{K}. For instance, if
the input array contains numbers 8, 4, 1, 6 and \emph{K} is 10, then
the answer is yes (4 and 6).
\begin{enumerate}
\item \textbf{(2 pts.)} Program a method
\begin{verbatim}
boolean sum2ToK (int [] a, int k)
\end{verbatim}
to do what you want.
\item \textbf{(2 pts.)} Give an execution time analysis of your method.
\item \textbf{(2 pts.)} Recall that there are algorithms for sorting arrays that are
  ${\cal O}(N \text{log}(N))$. Use this fact to write a new version of
  your program that is ${\cal O}(N \text{log}(N))$, proceed by first
  sorting the array \texttt{a} and then doing some linear extra work.
  \newline
  \underline{\textbf{Notice:}} You do NOT need to implement sort, you
  can assume that it is already programmed.
\end{enumerate}



\end{document}
